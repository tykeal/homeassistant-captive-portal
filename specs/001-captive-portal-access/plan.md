SPDX-FileCopyrightText: 2025 Andrew Grimberg
SPDX-License-Identifier: Apache-2.0

# Implementation Plan: Captive Portal Guest Access

**Branch**: `001-captive-portal-access` | **Date**: 2025-10-22 | **Spec**: ./spec.md
**Input**: Feature specification from `/specs/001-captive-portal-access/spec.md`

## Summary

Implement a pluggable captive portal enabling rental guest network access with voucher validation, administrative grant management, Home Assistant entity mapping, and TP-Omada controller integration. Deliver as a Home Assistant addon but runnable standalone (container) with consistent configuration.

## Technical Context

**Language/Version**: Python 3.13
**Primary Dependencies**: FastAPI (HTTP/API & admin UI simple templating), Jinja2 (theming templates), httpx (async HTTP to TP-Omada + HA REST), SQLModel (initial SQLite persistence), passlib/bcrypt (password hashing), pydantic (data validation), uv (package/environment manager), alembic (for future DB migrations if upgraded beyond SQLite)
**Storage**: Adopt SQLite via SQLModel behind a repository abstraction (Clarification Q1). Future upgrade path to PostgreSQL documented; no multi-instance requirement in v1.
**Testing**: pytest + pytest-asyncio; coverage enforcement; contract tests for controller API boundaries using recorded fixtures; integration tests spinning up FastAPI test client.
**Target Platform**: Home Assistant addon container (based on addons-example best practices) & generic OCI container (Docker/Podman)
**Project Type**: Single backend project (web portal + API) with minimal frontend templating (no SPA framework initially)
**Performance Baselines (p95 unless noted)**:
- Voucher redemption: ≤800ms (L1: 50 concurrent) / ≤900ms (L2: 200 concurrent)
- Auth login API: ≤300ms; Controller propagation (authorize→active): ≤25s; Admin grants list (500 grants): ≤1500ms
- Memory RSS: ≤150MB; CPU 1-min peak: ≤60% @ 200 concurrent; Merge gate: >10% regression vs baseline blocks
- Non-blocking IO (async); bandwidth shaping delegated to controller
**Scale/Scope**: Single property initial; design for extension to multiple controllers and properties (multi-tenancy deferred). Concurrent guests <50 typical; admin users <5.

## Constitution Check

Refer to `constitution_gate_checklist.md` for per-phase gate verification (introduced Phase 0, task T0009).

Gates derived from constitution:
- Atomic commits: Plan phases enforce granular task breakdown.
- SPDX headers: Template enforcement; automation script will insert headers for new files.
- TDD: Tests defined per phase before implementation tasks start (see Phases below).
- Performance baselines: SC-001..SC-003 mapped to test scaffolds; TODO(PERFORMANCE_BASELINES) remains for precise p95 thresholds.
- Pre-commit integrity: Add pre-commit config (ruff/black/pytest/REUSE, etc.) in Phase 0.
Status: All gates feasible; outstanding TODO: finalize storage engine decision & baseline numeric performance thresholds.

## Project Structure

### Documentation (this feature)

```text
specs/001-captive-portal-access/
├── plan.md
├── research.md            # Phase 0: controller API + HA API exploration
├── data-model.md          # Phase 1: ERD and entity definitions
├── quickstart.md          # Phase 1: install/run usage (addon + container)
├── contracts/             # Phase 1: API + controller interaction contracts
└── tasks.md               # Phase 2: Generated by /speckit.tasks
```

### Source Code (repository root)

```text
src/
├── core/                  # Core domain logic (entities, repositories)
├── controllers/           # Pluggable backend controllers (tp_omada/, base.py)
├── services/              # Business services (voucher_service.py, grant_service.py)
├── api/                   # FastAPI routers (auth.py, vouchers.py, grants.py, admin.py, mapping.py)
├── web/                   # Jinja2 templates & static assets (themes/ default/)
├── security/              # Password hashing, auth utils
├── persistence/           # DB session, migration hooks, storage abstraction
└── config/                # Settings, environment parsing

tests/
├── unit/
├── contract/              # Controller & HA API contract tests (mocked/fixture responses)
├── integration/           # FastAPI app end-to-end flows
└── performance/           # Benchmark scaffolds (later)
```

**Structure Decision**: Single backend project with modular directories; avoids premature multi-project complexity while enabling future controller additions via `controllers/` pluggable pattern.

## Phase Breakdown & TDD Sequencing

### Phase 0: Research & Environment Setup
Deliverables: research.md, initial pre-commit config, dependency selection, controller API analysis summary (mapping of needed endpoints), HA REST entity discovery notes.
Tests (author first): None functional yet; add placeholder performance baseline test scaffolds (skipped) and config loading unit tests.
Constitution Gate Re-check: Verify SPDX headers on new files, pre-commit active, TDD scaffolds present.

### Phase 1: Data Model & Contracts
Deliverables: data-model.md (Voucher, AccessGrant, AdminAccount, EntityMapping, AuditLog models), contracts/ (OpenAPI draft for internal API, JSON schema for voucher redemption request/response, controller interaction contract stubs).
Tests first: unit tests for model validation (pydantic), contract tests using mocked controller responses; negative tests for duplicate voucher race condition simulation.
Constitution Gate Re-check: Confirm all new files have SPDX headers, tests exist before implementation, atomic commit sequencing followed.

### Phase 2: Core Services (Voucher & Grant Logic)
Implement voucher creation, redemption flow, grant lifecycle (create/update/revoke), duplicate prevention semaphore/locking strategy.
Tests first: service-level unit tests (voucher expiration, grant extension), concurrency test for duplicate redemption.
Constitution Gate Re-check: Ensure tests failing before code, validate no pre-commit bypass, verify audit/logging tasks planned.

### Phase 3: Controller Integration (TP-Omada)
Implement adapter for TP-Omada external portal API interactions; retry queue for failures.
Tests first: contract tests with fixture responses; integration tests verifying grant propagation statuses.
Constitution Gate Re-check: Confirm adapter tests cover error paths (retry), metrics instrumentation test present before implementation.

### Phase 4: Admin Web Interface & Theming
Constitution Gate Re-check: Validate security headers, CSRF tests precede implementation, theme precedence test (remediation) added before UI changes.
Implement authentication (secure HTTP-only server-side session cookies + CSRF protection), admin CRUD for vouchers/grants, entity mapping UI, theming loader.
Tests first: integration tests for admin routes (auth success/failure), CSRF enforcement tests, template rendering checks (no sensitive data leakage).

### Phase 5: Home Assistant Entity Mapping Integration
Constitution Gate Re-check: Confirm mapping tests validate selection logic before service code; ensure SPDX headers on new files.
Polling or on-demand fetch of Rental Control entities; persistence of selected mapping; usage in authorization decisions.
Tests first: integration tests with mocked HA responses, mapping save/retrieve, fallback when HA unavailable.

### Phase 6: Performance & Hardening
Constitution Gate Re-check: Finalize performance baselines before removing test skips; enforce audit/log completeness tests present.
Add benchmark tests for voucher redemption path, log audit completeness tests, finalize performance baseline numbers.
Refactor for any identified bottlenecks.

### Phase 7: Polish & Documentation
Constitution Gate Re-check: Ensure documentation reflects final baselines, all SPDX headers verified, no skipped tests remain.
quickstart.md, finalize README additions, audit logging review, ensure all SPDX headers, license compliance review, addon build artifacts (Dockerfile, config.json) aligned with addons-example.
Tests: finalize performance threshold assertions (remove skips), documentation validation (lint).

## Role-Based Access Control (FR-017)

FR-017: System SHALL enforce role-based permissions: {Viewer: read dashboards only; Operator: viewer + trigger captive session resets; Admin: operator + manage vouchers/roles; Auditor: viewer + access immutable logs}. No other actions permitted (deny-by-default). Permission matrix documented and tests (authorization allow/deny, negative) precede implementation.

## Booking Identifier Validation (FR-018)

FR-018: System SHALL validate guest authorization (booking) codes against Rental Control events.
- Source Entities per integration: calendar.rental_control_<integration_id>, sensor.rental_control_<integration_id>_event_[0..N-1].
- Prioritized Events: event 0 (current or checking-out today), event 1 (upcoming/arriving today). All events 0..N-1 are eligible if within [start, end].
- Candidate Identifier Attributes: slot_code (default) or slot_name (admin-selectable per integration). Admin chooses once per integration; selection persisted.
- Formats: slot_code regex ^\d{4,}$; last_four regex ^\d{4}$ (last_four not used directly for auth in v1 but may be displayed/audited). slot_name treated as opaque string (non-empty, trimmed, <=128 chars).
- Guest Input: Single authorization code field (no username).
- Validation Window: Access allowed from event.start (floored to minute) until event.end (ceiled to minute). Access grants lifetime resolved to minute boundaries.
- Devices: Unlimited devices per valid booking within window.
- Failure Responses: 400 invalid format; 404 booking not found; 410 booking outside active window; 409 duplicate active grant (same code already redeemed and still valid) returns existing grant reference.
- Metrics: booking_lookup_latency (histogram), validation_fail_total (counter with reason labels: invalid_format, not_found, outside_window, duplicate).
- Audit Log: booking_code_attempt (code_hash, integration_id, outcome, reason, correlation_id).
- Future: Bandwidth limits & guest upgrade path (deferred; note for roadmap).
- Security: Deny-by-default if integration selection missing or events unavailable (reason: integration_unavailable).

## Complexity Tracking

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|---------------------------------------|
| Async architecture | Needed for non-blocking controller/HA calls | Sync IO would raise latency & block scaling |
| Pluggable controllers dir | Future multi-controller support | Single file adapter would become monolith |

## Initial Task Seeds (High-Level)
(Details deferred to /speckit.tasks)
- Setup uv project, pyproject.toml, add dependencies
- Add addon skeleton (Dockerfile, config.json, run script) based on home-assistant/addons-example
- Add pre-commit config (ruff, reuse, pytest, black if used)
- research.md: summarize TP-Omada endpoints (login, authorize, revoke) & HA entity endpoints
- data-model.md: define entities & relationships
- contracts/: define OpenAPI routers & controller interface spec
- Implement persistence abstraction + SQLite default (repository pattern)
- Voucher service + tests (create, validate, prevent duplicates)
- Grant service + tests (create, extend, revoke, audit logging)
- Controller adapter (tp_omada) + contract tests
- Admin auth (password hashing, secure HTTP-only session cookies + CSRF) + tests
- Web templates (portal page, admin dashboard) basic theme config
- HA mapping integration logic + tests
- Performance scaffolds (benchmark voucher redemption)

## Open Questions (Resolved Clarifications Applied)
1. Storage choice: RESOLVED → SQLite via SQLModel behind abstraction (Q1)
2. Admin auth mechanism: RESOLVED → Secure HTTP-only server-side session cookies + CSRF protection (Q2)

## Risk & Mitigation
- Controller API instability: Implement resilient retry with capped exponential backoff.
- Race conditions on voucher redemption: Use DB uniqueness + async lock.
- HA API latency/unavailability: Cache entity mapping, degrade gracefully.
- Performance regression risk: Add benchmark early Phase 6 before polish.

## Next Steps
Proceed to Phase 0 tasks ensuring test placeholders created before service logic. After Phase 1 completion run constitution re-check (coverage, TDD adherence, performance baseline TODOs tracked).
